def change_layer_fix_neurons_number(eq_params, process_params):
    # Usar SGD no lugar de adam
    # https://stats.stackexchange.com/questions/365778/what-should-i-do-when-my-neural-network-doesnt-generalize-well
    # https://arxiv.org/abs/1712.07628 
    # TODO refaz esse mesmo nondim e adam. E fim. Cabou-se. Credo.
    #1400 epochs 100n x3x8 800p domain 800p test horrivel erro >10
    #1400 epochs 160 x4x8 300p mb50 e sem mb ruinzão tb
    # Fazendo agora 90x8 que tinha dado certo antes
    # TODO roda um quadrado neuronios vs layers
    # Roda um adam, um sgd, um com nondim. E FIM!!!!
    # AÍ FAÇO OS GRÁFICOS 3D
    func = 'tanh' #'swish'#'tanh'
    # TODO antes de rodar o novo pelo amor passe só 700 pra testar e sem lbfgs
    # é pra demorar < 5 min que foi o quanto demorou pra maior qtde de neuronios
    n_epochs = 45000 #700
    #neurons = 90
    #layer=4
    dictionary = {}
    layers = [3, 6, 8, 12]
    # Vou ter que fazer em 2 partes...
    neurons = [22, 45, 70,]
    # neurons = [90, 130, 200,]
    # layers = [3, 12]
    # neurons = [22,70]
    # TODO lembre de ativar lbfgs de novo
    # cheque tudo num step de tipo 1500 antes de fazer o grande
    # pra ver se vai dar bode, estourar etc
    # TODO sgd parece mais suscetível à quebra que adam???

    for n in neurons:
        for l in layers:
            dictionary[f'{n}x{l} {func} sgd'] = {
                'layer_size': [1] + [n] * l + [4],
                "sgd_epochs": n_epochs,
            }

    # dictionary = { 
    #     f'{neurons}x{layer} {func} sgd nondim':{
    #         "sgd_epochs": n_epochs,
    #         'layer_size': [1] + [neurons] * layer + [4],
    #         'X_S': eq_params.Xm,
    #         "P_s": eq_params.Pm,
    #         "S_s":eq_params.So,
    #         "V_s": process_params.max_reactor_volume
    #     },
    #     f'{neurons}x{layer} {func} adam nondim':{
    #         "adam_epochs": n_epochs,
    #         'layer_size': [1] + [neurons] * layer + [4],
    #         'X_S': eq_params.Xm,
    #         "P_s": eq_params.Pm,
    #         "S_s":eq_params.So,
    #         "V_s": process_params.max_reactor_volume
    #     },
    #     f'{neurons}x{layer} {func} sgd adam nondim':{
    #         "adam_epochs": int(n_epochs/2),
    #         "sgd_epochs": int(n_epochs/2),
    #         'layer_size': [1] + [neurons] * layer + [4],
    #         'X_S': eq_params.Xm,
    #         "P_s": eq_params.Pm,
    #         "S_s":eq_params.So,
    #         "V_s": process_params.max_reactor_volume,
    #     },
    #     f'{neurons}x{layer} {func} adam nondim W':{
    #         "adam_epochs": n_epochs,
    #         'layer_size': [1] + [neurons] * layer + [4],
    #         'X_S': eq_params.Xm,
    #         "P_s": eq_params.Pm,
    #         "S_s":eq_params.So,
    #         "V_s": process_params.max_reactor_volume,
    #         'w_S':15,
    #         'w_P': 3,
    #     },
    # }


    for key in dictionary:
        dictionary[key]['activation'] = func
        dictionary[key]['num_domain'] = 300
        dictionary[key]['num_test'] = 300
        dictionary[key]["lbfgs_pre"] = 0
        dictionary[key]["lbfgs_post"] = 2 #0 #3
        dictionary[key]['LR'] = 0.0000005
        # 0.00004 quebrou o 70x8 0.00001 quebrou o 120x3
        # 0.000004 tb querou 120x3, melhor tirar ele
        dictionary[key]['hyperfolder'] = f'fb'#f'fb{neurons}n{func}'
        dictionary[key]['initializer'] = 'Glorot normal' #GLOROT UNIFORM
        
        dictionary

    return dictionary
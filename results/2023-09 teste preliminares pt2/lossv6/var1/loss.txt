for o in outputSimulationType.order:
                # Pode dar NaN quando predizer valores abaixo de 0
                # Então evite divisões!!!! Por isso o V vem multiplicando no fim...
                loss_version = solver_params.get_loss_version_for_type(o)

                if o == "X":
                    deriv_calc = V * rX + (f_in * inlet.X - f_out * X)
                    loss_derivative = dXdt * V - deriv_calc
                    loss_X = 0
                    if loss_version >= 6:
                        loss_maxmin = tf.where(
                            tf.less(X, 0),
                            tf.math.pow(X, 3),
                            tf.where(
                                tf.greater(X, tf.ones_like(X) * Xm),
                                X - Xm,
                                tf.zeros_like(X),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        sign_deriv_pred = tf.math.sign(dXdt)
                        sign_deriv_calc = tf.math.sign(deriv_calc)
                        loss_multiplier = tf.abs(
                            sign_deriv_pred - sign_deriv_calc
                        )

                        loss_V = 100*(1 + 10 * loss_multiplier) * (
                            20*loss_derivative_abs + loss_maxmin_abs
                        )
                        pass
                    if loss_version >= 5:
                        loss_maxmin = tf.where(
                            tf.less(X, 0),
                            tf.math.pow(X, 3),
                            tf.where(
                                tf.greater(X, tf.ones_like(X) * Xm),
                                X - Xm,
                                tf.zeros_like(X),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_X = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version == 4:
                        # if X<0, return X
                        # else if X>Xm, return X
                        # else return loss_X
                        loss_maxmin = tf.where(
                            tf.less(X, 0),
                            X,
                            tf.where(tf.greater(X, Xm), X - Xm, tf.zeros_like(X)),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_X = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version <= 3:
                        loss_X = loss_derivative
                    loss_pde.append(loss_X)

                elif o == "P":
                    deriv_calc = V * rP + (f_in * inlet.P - f_out * P)
                    loss_derivative = dPdt * V - deriv_calc
                    loss_P = 0
                    if loss_version >= 6:
                        loss_maxmin = tf.where(
                            tf.less(S, 0),
                            tf.math.pow(S, 3),
                            tf.where(
                                tf.greater(S, tf.ones_like(S) * initial_state.S[0]),
                                S - initial_state.S[0],
                                tf.zeros_like(S),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        sign_deriv_pred = tf.math.sign(dPdt)
                        sign_deriv_calc = tf.math.sign(deriv_calc)
                        loss_multiplier = tf.abs(
                            sign_deriv_pred - sign_deriv_calc
                        )

                        loss_V = (1 + 10 * loss_multiplier) * (
                            loss_derivative_abs + loss_maxmin_abs
                        )
                    if loss_version >= 5:
                        loss_maxmin = tf.where(
                            tf.less(P, 0),
                            tf.math.pow(P, 3),
                            tf.where(
                                tf.greater(P, Pm),
                                P - tf.ones_like(P) * Pm,
                                tf.zeros_like(P),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_P = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version == 4:
                        loss_maxmin = tf.where(
                            tf.less(P, 0),
                            P,
                            tf.where(tf.greater(P, Pm), P - Pm, tf.zeros_like(P)),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_P = loss_derivative_abs + loss_maxmin_abs

                    elif loss_version <= 3:
                        loss_P = loss_derivative
                    loss_pde.append(loss_P)

                elif o == "S":
                    deriv_calc = V * rS + (f_in * inlet.S - f_out * S)
                    loss_derivative = dSdt * V - deriv_calc
                    loss_S = 0
                    if loss_version >= 6:
                        loss_maxmin = tf.where(
                            tf.less(S, 0),
                            tf.math.pow(S, 3),
                            tf.where(
                                tf.greater(S, tf.ones_like(S) * initial_state.S[0]),
                                S - initial_state.S[0],
                                tf.zeros_like(S),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        sign_deriv_pred = tf.math.sign(dSdt)
                        sign_deriv_calc = tf.math.sign(deriv_calc)
                        # If equal, = 0
                        # If not, = -1 or +1 or +2 or -2
                        loss_multiplier = tf.abs(
                            sign_deriv_pred - sign_deriv_calc
                        )

                        loss_V = (1 + 10 * loss_multiplier) * (
                            loss_derivative_abs + loss_maxmin_abs
                        )
                    if loss_version >= 5:
                        loss_maxmin = tf.where(
                            tf.less(S, 0),
                            tf.math.pow(S, 3),
                            tf.where(
                                tf.greater(S, tf.ones_like(S) * initial_state.S[0]),
                                S - initial_state.S[0],
                                tf.zeros_like(S),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_S = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version == 4:
                        loss_maxmin = tf.where(
                            tf.less(S, 0),
                            S,
                            tf.where(
                                tf.greater(S, initial_state.S[0]),
                                S - initial_state.S[0],
                                tf.zeros_like(S),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_S = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version <= 3:
                        loss_S = loss_derivative
                    loss_pde.append(loss_S)

                elif o == "V":
                    dVdt_calc = f_in - f_out
                    loss_derivative = dVdt - dVdt_calc
                    loss_V = 0
                    if loss_version >= 6:
                        loss_maxmin = tf.where(
                            tf.less(V, 0),
                            tf.math.pow(V, 3),
                            tf.zeros_like(V),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)

                        sign_deriv_pred = tf.math.sign(dVdt)
                        sign_deriv_calc = tf.math.sign(dVdt_calc)
                        # If equal, = 0
                        # If not, = -1 or +1 or +2 or -2
                        loss_multiplier = tf.abs(
                            sign_deriv_pred - sign_deriv_calc
                        )

                        loss_V = (1 + 10 * loss_multiplier) * (
                            20*loss_derivative_abs + loss_maxmin_abs
                        )
                    elif loss_version == 5:
                        loss_maxmin = tf.where(
                            tf.less(V, 0),
                            tf.math.pow(V, 3),
                            tf.zeros_like(V),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_V = loss_derivative_abs + loss_maxmin_abs
                    if loss_version == 4:
                        loss_maxmin = tf.where(
                            tf.less(V, 0),
                            V,
                            tf.zeros_like(V),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_V = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version <= 3:
                        loss_V = loss_derivative

                    loss_pde.append(loss_V)
for o in outputSimulationType.order:
                # Pode dar NaN quando predizer valores abaixo de 0
                # Então evite divisões!!!! Por isso o V vem multiplicando no fim...
                loss_version = solver_params.get_loss_version_for_type(o)

                if o == "X":
                    loss_derivative = dXdt * V - (V * rX + (f_in * inlet.X - f_out * X))
                    loss_X = 0
                    if loss_version >= 5:
                        loss_maxmin = tf.where(
                            tf.less(X, 0),
                            tf.math.pow(X, 3),
                            tf.where(
                                tf.greater(X, tf.ones_like(X) * Xm),
                                X - Xm,
                                tf.zeros_like(X),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_X = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version == 4:
                        # if X<0, return X
                        # else if X>Xm, return X
                        # else return loss_X
                        loss_maxmin = tf.where(
                            tf.less(X, 0),
                            X,
                            tf.where(tf.greater(X, Xm), X - Xm, tf.zeros_like(X)),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_X = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version <= 3:
                        loss_X = loss_derivative
                    loss_pde.append(loss_X)

                elif o == "P":
                    loss_derivative = dPdt * V - (V * rP + (f_in * inlet.P - f_out * P))
                    loss_P = 0
                    if loss_version >= 5:
                        loss_maxmin = tf.where(
                            tf.less(P, 0),
                            tf.math.pow(P, 3),
                            tf.where(
                                tf.greater(P, Pm),
                                P - tf.ones_like(P) * Pm,
                                tf.zeros_like(P),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_P = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version == 4:
                        loss_maxmin = tf.where(
                            tf.less(P, 0),
                            P,
                            tf.where(tf.greater(P, Pm), P - Pm, tf.zeros_like(P)),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_P = loss_derivative_abs + loss_maxmin_abs

                    elif loss_version <= 3:
                        loss_P = loss_derivative
                    loss_pde.append(loss_P)

                elif o == "S":
                    loss_derivative = dSdt * V - (V * rS + (f_in * inlet.S - f_out * S))
                    loss_S = 0
                    if loss_version >= 5:
                        loss_maxmin = tf.where(
                            tf.less(S, 0),
                            tf.math.pow(S, 3),
                            tf.where(
                                tf.greater(S, tf.ones_like(S) * initial_state.S[0]),
                                S - initial_state.S[0],
                                tf.zeros_like(S),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_S = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version == 4:
                        loss_maxmin = tf.where(
                            tf.less(S, 0),
                            S,
                            tf.where(
                                tf.greater(S, initial_state.S[0]),
                                S - initial_state.S[0],
                                tf.zeros_like(S),
                            ),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_S = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version <= 3:
                        loss_S = loss_derivative
                    loss_pde.append(loss_S)

                elif o == "V":
                    dVdt_calc = f_in - f_out
                    loss_derivative = dVdt - dVdt_calc
                    loss_V = 0
                    if loss_version >= 5:
                        loss_maxmin = tf.where(
                            tf.less(V, 0),
                            tf.math.pow(V, 3),
                            tf.zeros_like(V),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_V = loss_derivative_abs + loss_maxmin_abs
                    if loss_version == 4:
                        loss_maxmin = tf.where(
                            tf.less(V, 0),
                            V,
                            tf.zeros_like(V),
                        )
                        loss_derivative_abs = tf.abs(loss_derivative)
                        loss_maxmin_abs = tf.abs(loss_maxmin)
                        loss_V = loss_derivative_abs + loss_maxmin_abs
                    elif loss_version <= 3:
                        loss_V = loss_derivative

                    loss_pde.append(loss_V)

            if solver_params.loss_version == 5:
                pass
                # # Normalize
                # loss_pde_total = 0
                # old_loss_pde = loss_pde
                # for loss_n in old_loss_pde:
                #     loss_pde_total += loss_n
                # # Essa loss é pra fazer com que estejam no máximo
                # # a 1 casa decimal de distância
                # loss_pde = [
                #     (loss_n + loss_pde_total) for loss_n in old_loss_pde
                # ]

            return loss_pde
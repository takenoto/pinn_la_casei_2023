PRA FRENTE JÁ NA NOVA LOSS V2. PARA EVITAR ESSES VALORES ABAIXO DE 0. !!!!!!!!!!!!!!

Conclusões 1ª rodada:
- Me parece que o X e o P podem estar sendo previstos altíssimos, aí o condicional taca eles na condição de topo. Daí ele prevê o que bem entende?


Rodei a 1ª vez assim:



# Tá parecendo que 300/300 de treino teste tinham resultados bem melhores
def change_layer_fix_neurons_number(eq_params, process_params):
    func = "tanh"  #'tanh' #'swish'
    mini_batch = 25 #None  # 50 #200
    # Com glorot normal s swish cstr se quebrou mds
    initializer = "Glorot uniform"  #'Glorot normal' #'Glorot normal' #'Orthogonal' #GLOROT UNIFORM # Era Glorot Normal nos testes sem swish
    # LR = 0.0001 #0.000001  # 0.001 #0.001
    LR = 0.001
    # 0 lbfgs e 100 adam rodou né. Vamos ver com mais agora...
    lbfgs_post = 1 #1#2#2 #1 #4
    ADAM_EPOCHS = 1000#25000#3000 #25000 #45000 #1000 #25000 #20000  # 10000 #1000 #100 #35000
    SGD_EPOCHS = None  # 1000
    dictionary = {}
    # neurons = [140, 85, 40, 20]#, 80]#[80, 60, 40]  # , 70]
    # layers = [10, 8, 4]#, 8]  # [8]#, 6]
    # neurons = [200, 120, 60, 45]
    # layers = [5, 4]
    # neurons = [80, 60, 45]
    # neurons = [120, 85, 60]
    # layers = [8, 6, 3]
    neurons = [120, 60]
    layers = [8, 3]
    cols = len(layers)
    rows = len(neurons)

    # Se irá aplicar a estratégia de adimensionalização padrão
    IS_NONDIM = False
    IS_LOSS_WEIGHT = False

    # Me parece que quando usa 2 var de entrada precisa de um NUM_DOMAIN e teste bem maior pra ficar razoável
    NUM_DOMAIN = 100#900 #1000 #300  # 800 #100 #900 #1000
    NUM_TEST = 100#900 #1000 #300  # 800 #100 #400 #1000
    NUM_INIT = 25#1000 #600
    NUM_BOUNDARY = 0 #6000 #0  # 2 #200 #100

    # Anota aqui as variáveis que vão ser suportadas nessa simulação
    # supported_variables = ['X', 'P', 'S', 'V']
    # Por padrão, t de entrada e XPSV de saída:
    output_variables = ["X", "P", "S", "V"]
    input_variables = ["t"]
    # Alternativamente, PSV de saída e tX de entrada
    # output_variables = ["X", "P", "S"]
    # input_variables = ["t", "V"]

    for n in neurons:
        for l in layers:
            key = f"{n}x{l} {func}"
            dictionary[key] = {
                "layer_size": [len(input_variables)]
                + [n] * l
                + [len(output_variables)],
                "adam_epochs": ADAM_EPOCHS,
                "sgd_epochs": SGD_EPOCHS,
            }
            if IS_NONDIM:
                # dictionary[key]['t_s'] = process_params.t_final
                dictionary[key]["X_s"] = (eq_params.Xm,)
                dictionary[key]["P_s"] = (eq_params.Pm,)
                dictionary[key]["S_s"] = eq_params.So
                dictionary[key]["V_s"] = process_params.max_reactor_volume

            if IS_LOSS_WEIGHT:
                dictionary[key]["w_X"] = 1/10 # 100 # 1 / 3
                dictionary[key]["w_P"] = 1 # 1000 #1 / 100
                dictionary[key]["w_S"] = 1/100 #1/10 #1 / 1000
                dictionary[key]["w_V"] = 1

    for key in dictionary:
        dictionary[key]["activation"] = func
        if mini_batch:
            dictionary[key]["mini_batch"] = mini_batch
        dictionary[key]["num_domain"] = NUM_DOMAIN
        dictionary[key]["num_test"] = NUM_TEST
        dictionary[key]["num_init"] = NUM_INIT
        dictionary[key]["num_bound"] = NUM_BOUNDARY
        dictionary[key]["lbfgs_pre"] = 0
        dictionary[key]["lbfgs_post"] = lbfgs_post
        dictionary[key]["LR"] = LR
        dictionary[key][
            "hyperfolder"
        ] = f'cstr t {"ND" if IS_NONDIM else ""} 2023_08_12'
        dictionary[key]["isplot"] = True
        dictionary[key]["initializer"] = initializer
        dictionary[key]["output_variables"] = output_variables
        dictionary[key]["input_variables"] = input_variables

        dictionary

    return (dictionary, cols, rows)
